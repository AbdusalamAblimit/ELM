# 《程序设计高级实践》第三组项目特色

## 需求分析

根据项目的任务书，我们花了一周的做了非常完整的需求分析，除了基本的业务流程分析和功能性需求的分析之外，我们还对性能需求、安全需求、可用性、可维护性、可扩展性、技术选型等非功能性需求做了详细的分析，编写了希求规格说明书。这个工作对我们后续的设计与开发工作起了非常重要的作用。

![image-20230411011840048](https://abdusalam-typora.oss-cn-beijing.aliyuncs.com/img-for-typora/image-20230411011840048.png)



## 项目架构设计



![image-20230410165253574](https://abdusalam-typora.oss-cn-beijing.aliyuncs.com/img-for-typora/image-20230410165253574.png)

上图是我们需求分析阶段绘制的项目总体架构图，除了课程项目要求的这些微服务之外，我们还新增了redis服务器，它用于分布式锁的实现，还为Gateway网关服务器设计了**响应缓存过滤器**和响应过期过滤器，这些稍后会进行详细的讲述。



· 我们要求虚拟钱包、积分、订单等设计金钱流动的业务需要保证严格的**一致性**，其他业务无需严格保证一致性。

· 我们在微服务通信，gateway网关等处设计了超时和熔断降级机制，保证了前端发来的每一个请求都能够有响应。

· 严格规定了业务相关的微服务之间不能存在循环依赖或双向依赖，提高了项目的分区容错性。

## 设计开发中的细节

因为时间关系，我们在这里主要讲述我们设计与开发当超过或不同于课程任务要求的工作。

### 云服务器

​	我们租了两台阿里云服务器，项目开发的初期就把**服务注册中心**、**配置中心**、**消息队列**、**网关**等服务器部署了上去，并且每当一个微服务开发完成，就部署上去。这样的开发方式使我们在开发过程中，无需在本地运行所有依赖的微服务，只需运行正在开发的微服务。

   我们最后把所有的微服务都部署上去了，老师和同学们可以通过访问(http://8.130.64.168:8081/)这个URL来是用我们的项目成果。

### RestfulAPI

我们对所有业务的接口进行了重构，使其符合Restful规范，严格规定了请求方法、请求路径的格式、传参方式等，使得我们的接口更加简洁，容易维护。比如：

> 获取某个id的商家
>
> 旧：
>
> ```
> ANY_MATHOD http://ip:port/elm/getBusinessById?businessId={businessId}
> ```
>
> 新
>
> ```
> GET http://ip:port/businesses/{businessId}
> ```
>
> 

以前我们要获取特定id的商家信息时的接口是getBusinessById后面接上查询参数，请求方法是任意的。

现在我们把数据库表中的每一项视为了一项资源，把HTTP请求的URL视为了资源的路径，通过请求方法GET来获取资源。这样设计的接口非常简洁易懂，容易维护，也方便了前端开发的组员。



我们发现智慧树上的课程视频里的接口设计不是特别符合RestfulAPI风格：

> 旧的：
>
> ```
> ANY_MATHOD http://ip:port/elm/getBusinessById?businessId={businessId}
> ```
>
> 教学视频里的：
>
> ```
> GET http://ip:port/businesses/getBusinessById/businessId/{businessId}
> ```
>
> 我们的：
>
> ```
> GET http://ip:port/businesses/{businessId}
> ```

视频里说“我们接口的设计要符合restful规范”，但是URL里还是有`/getBusinessById`这样的词出现，我们认为这样的写法跟以综合实践项目中的写法没有本质的区别，也不符合把“**表项视为资源**”这个思想。因此，我们没有采纳课件中的接口设计方案，而是自己设计了一套restful接口，并且编写了一个**《Restful API接口规格说明书》**，详细的规定了项目中的每一个接口的**请求方法**、**资源路径格式**、**响应格式**等，为前后端分离同时开发打下了基础，前端同学只需根据**接口规格说明书**进行开发，无需等待后端的完成。前后端严格遵守接口文档进行开发，也保证了后期前后端对接的顺利进行。



### 业务对象的优化

我们发现教学视频中某些业务对象的设计存在一些问题：

#### 1. 金额属性不要使用double

```java
class Food{
    //....
	private double foodPrice;
    //...
}
```

在商品价格、商家起送费、配送费这些有关金钱的属性上，教学视频使用了double类型，但是由于float、double类型的尾数部分的位数是固定的，一旦需要表示的数字的精度高于浮点数的精度，那么必然产生误差。甚至有些”**x.yz“**这样精确到小数点后两位的数字,double也不能精确表示，这在处理金融数据的情况下是绝对不允许存在的。因此，我们把所有金钱相关的属性的类型都换成了BigDecimal。



#### 2.不同业务对象之间的嵌套：

综合实践中我们跟着教学视频进行开发，导致我们的项目存在一些这样的代码：



```java
class Order{
    //...
    Business business;   //订单所属商家
    List<Cart> list; 	 //订单里的购物车
    //...
}
```

```java
class Cart
{
	//...
	Food food;  	//对应的食品
	//...
}
```

```java
class Food{
    //....
    Busienss business; //食品所属商家
    String img;
    //....
}
```



食品和商家对象中都有自己的图片。食品中套了商家对象，购物车里套了个食品对象，订单里套了商家对象和购物车列表。这就导致了一个订单信息动不动就好几兆的，因为食品和商家有它们的图片。同时这造成了微服务之间的耦合度比较高。请求一个订单信息有时候1秒左右，我们部署到远程服务器上之后，需要等待5-8秒。这种设计是不好的。



因此，我们对相关代码进行了重构，我们没有在一个业务对象里面直接存储另一种业务对象，而是存储了**主键**，前端如果需要获取订单里的食品信息，那么就根据**订单信息里的FoodId**向食品微服务请求获取就可以了。

```
class Order{
    //...
    Integer id;   //订单所属商家id
    List<Integer> list; 	 //订单里的购物车id
    //...
}
```

```java
class Cart
{
	//...
	Integer foodId;  	//对应的食品id
	//...
}
```

```java
class Food{
    //....
    Integer businessId; //食品所属商家
    String img;
    //....
}
```

这样的重构降低了微服务之间的依赖程度、耦合度，还极大的缩短了相关业务的响应时间，提高了用户体验。



### Gateway网关过滤器的设计

考虑到这种情况：

**用户获取商家列表**：

![image-20230411025502245](https://abdusalam-typora.oss-cn-beijing.aliyuncs.com/img-for-typora/image-20230411025502245.png)

由于每个商家都有图片，一个商家列表大约是200KB大小，这两百KB的数据将会经过4三次中转才会到达用户的浏览器。整个请求涉及8次端与端之间的通信。在我们把商家微服务部署到云服务器上之后，每次点开商家列表都需要等待4秒钟左右。

一个商家或者一个食品在一段时间内改变的概率很小，而获取这个商家或食品的请求可能会有很多很多次。基于这个考虑，我们在网关服务器上为食品微服务和商家微服务添加了缓存机制。



![image-20230411030557487](https://abdusalam-typora.oss-cn-beijing.aliyuncs.com/img-for-typora/image-20230411030557487.png)

这样的话，一段时间对于特定商家(或食品)的第一次请求会消耗较长时间，此时网关服务器将会缓存响应体。接下来对于相同资源的请求将会直接由网关返回，不会再去调用具体业务的微服务。



当网关收到了改变某个食品或商家的请求时，将会从本地的缓存中清除对应的响应体。确保下一次获取到的资源不是缓存中的旧资源。



缓存机制是通过Gateway的过滤器实现的：

> pre类型过滤器（向微服务转发请求前调用的过滤器）： 
>
> ​		(1) 缓存获取过滤器： 请求方式为GET时调用。如果本地存在缓存，则返回缓存，否则向微服务转发请求。
>
> ​		(2) 缓存请求过滤器:  请求方式为PUT时调用。如果本地该资源存在缓存，则清除缓存
>
> post类型过滤器(收到微服务响应后调用的过滤器)：
>
> ​		(1) 缓存存储过滤器：请求方式为GET时调用，把微服务返回的响应体存储到本地缓存中

由于目前数据库的规模小，网关服务器足以存储整个商家表和食品表，因此暂时没有建立**缓存淘汰机制**，如果后续有机会继续做这个项目，则会加入。



### 分布式锁的实现

这是我们额外实现的一个功能。

在单机版的虚拟钱包中，我们需要通过互斥锁的机制保证一个用户在同一时间内只能进行`充值`、`提现`、`转账`中的一个，防止同一用户在同一时间提交多笔交易请求。

```java
private final ConcurrentHashMap<String, Object> userLocks = new ConcurrentHashMap<>();
@Override
public Integer credit(String userId, BigDecimal amount) {
    Object userLock = userLocks.computeIfAbsent(userId, k -> new Object());
    synchronized (userLock) {
        //............
    }
}

@Override
public Integer debit(String userId, BigDecimal amount) {
    Object userLock = userLocks.computeIfAbsent(userId, k -> new Object());
    synchronized (userLock) {
		//.........
    }
}
```

在交易开始时，我们以用户ID为键，从类内的 ConcurrentHashMap中拿到锁，同一用户的其他交易则需要在这里等待拿到锁的交易的完成。

但是我们想到，虚拟钱包微服务如果部署成了集群，从类内部获取锁的这种机制是无效的。因此，我们设计了一个分布式锁的机制，让每个虚拟钱包服务器从另一个服务器中获取锁。

<img src="https://abdusalam-typora.oss-cn-beijing.aliyuncs.com/img-for-typora/image-20230411154253706.png" alt="image-20230411154253706" style="zoom:50%;" />

为了防止某个拿到锁的虚拟钱包主机崩溃，无法释放锁，导致死锁等情况的发生，我们规定了如果每个微服务最多会持有一个锁10秒钟。

这种分布式锁机制在订单微服务的付款等业务里也有部署，我们牺牲了一点性能，换来了金钱相关业务严格的**一致性**。









